<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>typescript | Wen</title><meta name="keywords" content="ts"><meta name="author" content="肖智文"><meta name="copyright" content="肖智文"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="typeScriptTS是对JS进行扩展,TS代码最终也会换成JS, JavaScript是弱类型, 很多错误只有在运行时才会被发现 .而TypeScript提供了一套静态检测机制, 可以帮助我们在编译时就发现错误，ts是后置类型判断. ts工作流程：  、 ts原理：ts经过编译器处理会生成一系列的token，token组成一颗AST（抽象语法树），对AST进行类型检查，最后根据AST生成js代">
<meta property="og:type" content="article">
<meta property="og:title" content="typescript">
<meta property="og:url" content="https://xiaozhwien.cluod/ts/typeScript/index.html">
<meta property="og:site_name" content="Wen">
<meta property="og:description" content="typeScriptTS是对JS进行扩展,TS代码最终也会换成JS, JavaScript是弱类型, 很多错误只有在运行时才会被发现 .而TypeScript提供了一套静态检测机制, 可以帮助我们在编译时就发现错误，ts是后置类型判断. ts工作流程：  、 ts原理：ts经过编译器处理会生成一系列的token，token组成一颗AST（抽象语法树），对AST进行类型检查，最后根据AST生成js代">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png">
<meta property="article:published_time" content="2022-07-08T02:08:01.000Z">
<meta property="article:modified_time" content="2022-09-04T09:07:48.880Z">
<meta property="article:author" content="肖智文">
<meta property="article:tag" content="ts">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><link rel="shortcut icon" href="https://xiaozhiwen-hexo.oss-cn-hangzhou.aliyuncs.com/hexo-img/favicon.png"><link rel="canonical" href="https://xiaozhwien.cluod/ts/typeScript/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e8b269d29f11d37885649e49b2e1a22e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 肖智文","link":"链接: ","source":"来源: Wen","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#8b7a5d","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'typescript',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-04 17:07:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/JS-Heo@main/bb/showbb_in_index.css"><link rel="stylesheet" href="/self/wen.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xiaozhiwen-hexo.oss-cn-hangzhou.aliyuncs.com/hexo-img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-bomb"></i><span> 我的动态</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-camera-retro"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Wen</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-bomb"></i><span> 我的动态</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-camera-retro"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">typescript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-08T02:08:01.000Z" title="发表于 2022-07-08 10:08:01">2022-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-04T09:07:48.880Z" title="更新于 2022-09-04 17:07:48">2022-09-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ts/">ts</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="typeScript"><a href="#typeScript" class="headerlink" title="typeScript"></a>typeScript</h1><p>TS是对JS进行扩展,TS代码最终也会换成JS, JavaScript是弱类型, 很多错误只有在<strong>运行时才会被发现</strong> .而TypeScript提供了一套<strong>静态检测机制</strong>, 可以帮助我们在编译时就发现错误，ts是后置类型判断.</p>
<p>ts工作流程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./image/dea0cbad55b246a8a7e65aec57273ade_tplv-k3u1fbpfcp-z.webp"></p>
<p>、</p>
<p>ts原理：ts经过编译器处理会生成一系列的token，token组成一颗AST（抽象语法树），对AST进行类型检查，最后根据AST生成js代码。（类似babe;）</p>
<p>一些开发工具：</p>
<p><a target="_blank" rel="noopener" href="https://apihelper.jccore.cn/jsontool" title="JSON TO TS">JSON TO TS</a>：为指定的 JSON 数据生成对应的 TypeScript 接口定义。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>方式一：使用tsc&amp;#x20;</p>
<p><code>npm i -g typescript</code> 全局安装typescript</p>
<p><code>tsc ./xx.ts</code>  转换成js代码</p>
<p><code>node ./xx.js</code>  运行转换后的js代码</p>
<p>监控文件变化</p>
<p><code>tsc ./xx.ts -w</code>    监视ts文件的变化，一旦变化就转换为js文件。</p>
<p><code>tsc -init</code> 初始化配置文件，会生成一个tsconfig.json文件。</p>
</li>
</ol>
<ul>
<li><p>方式二：使用ts-node(推荐方式)</p>
<p><code>npm i -g  ts-node</code>  全局安装ts-node编译环境,会自动转换，不需要先转换为js</p>
<p><code>ts-node ./xxx.ts</code> 运行ts</p>
</li>
<li><p>方式三：code runner</p>
<p>使用vs code中的code runner插件，直接运行</p>
</li>
</ul>
<p><strong>.d.ts 声明文件</strong></p>
<p>JS文件+.d.ts文件 &#x3D;&#x3D;&#x3D; ts文件<br>.d.ts文件可以让JS文件继续维持自己JS文件的身份，而拥有TS的类型保护一般我们写业务代码不会用到，但是点击类型跳转一般会跳转到.d.ts文件</p>
<p><strong>tsconfig.json配置文件</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,                       <span class="comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,                  <span class="comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [],                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="string">&quot;checkJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span>,                     <span class="comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,                   <span class="comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span></span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,                     <span class="comment">// 生成相应的 &#x27;.map&#x27; 文件</span></span><br><span class="line">    <span class="string">&quot;outFile&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./&quot;</span>,                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="string">&quot;rootDir&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>,                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="string">&quot;noEmit&quot;</span>: <span class="literal">true</span>,                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="string">&quot;importHelpers&quot;</span>: <span class="literal">true</span>,                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="string">&quot;isolatedModules&quot;</span>: <span class="literal">true</span>,               <span class="comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="string">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span>,              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="string">&quot;noImplicitThis&quot;</span>: <span class="literal">true</span>,                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="string">&quot;alwaysStrict&quot;</span>: <span class="literal">true</span>,                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="string">&quot;noUnusedLocals&quot;</span>: <span class="literal">true</span>,                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="string">&quot;noUnusedParameters&quot;</span>: <span class="literal">true</span>,            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="string">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>,             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="string">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="literal">true</span>,    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,            <span class="comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;&#125;,                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="string">&quot;rootDirs&quot;</span>: [],                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="string">&quot;typeRoots&quot;</span>: [],                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="string">&quot;types&quot;</span>: [],                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="string">&quot;sourceRoot&quot;</span>: <span class="string">&quot;./&quot;</span>,                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="string">&quot;mapRoot&quot;</span>: <span class="string">&quot;./&quot;</span>,                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="string">&quot;inlineSourceMap&quot;</span>: <span class="literal">true</span>,               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="string">&quot;inlineSources&quot;</span>: <span class="literal">true</span>,                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="一、数据类型-amp-x20"><a href="#一、数据类型-amp-x20" class="headerlink" title="一、数据类型&amp;#x20;"></a>一、数据类型&amp;#x20;</h1><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p>简单数据类型</p>
<p>string、number 、 bigint、boolean、symbol、字面量</p>
<blockquote>
<p><code>number</code>和<code>bigint</code>都表示数字，但是这两个类型不兼容。</p>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把 <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和自身</p>
</blockquote>
<p>复杂数据类型</p>
<ul>
<li><p>数组类型Array 在ts中 array一般是指 所有元素类型相同的值的集合。</p>
</li>
<li><p>元组类型Tuple</p>
</li>
</ul>
<p>特殊类型</p>
<ul>
<li>any、unknown、undefined、null、void、never、object</li>
</ul>
<h2 id="2-详解"><a href="#2-详解" class="headerlink" title="2.详解"></a>2.详解</h2><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><p>使用字面量进行类型声明, 则该字面量就是该类型， 并只能赋予指定的值，可以理解为就是一个常量。单个的字面量用处不大。关键是结合使用联合类型。</p>
<p>使用<strong>字面量联合类型相当于使用了枚举类型，规定只能使用其中的元素。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="number">10</span>;  <span class="comment">//字面量，a只能赋值10</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">11</span>;    <span class="comment">//出错，不能将类型“11”分配给类型“10”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>  <span class="attr">b</span>: <span class="string">&quot;male&quot;</span> | <span class="number">11</span>  <span class="comment">//或  使用  |  连接多个类型（联合类型）。</span></span><br><span class="line">b = <span class="string">&quot;male&quot;</span></span><br><span class="line">b = <span class="number">11</span></span><br><span class="line">b = <span class="string">&#x27;any&#x27;</span>  <span class="comment">//出错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>字面量当作枚举类型</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="attr">size</span>: <span class="string">&#x27;small&#x27;</span> | <span class="string">&#x27;big&#x27;</span>;    <span class="comment">//size只有 small 和big两个选项。</span></span><br><span class="line">    <span class="attr">isEnable</span>:  <span class="literal">true</span> | <span class="literal">false</span>;</span><br><span class="line">    <span class="attr">margin</span>: <span class="number">0</span> | <span class="number">2</span> | <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>声明数组，有两种方式。建议优先使用第一种方式书写，否则在React的JSX语法中可能会冲突。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在元素类型后面加上[]</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: number[] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用数组泛型</span></span><br><span class="line"><span class="comment">//Array&lt;T&gt;  指定的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<strong>联合类型</strong>声明可以存储不同类型的数组，必须加上 <strong>（）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: (number | string)[] = [<span class="number">1</span>, <span class="string">&quot;string&quot;</span>, <span class="number">2</span>];  </span><br><span class="line"></span><br><span class="line"><span class="comment">//对象数组的定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">xiaoJieJies</span>: &#123; <span class="attr">name</span>: string, <span class="attr">age</span>: <span class="title class_">Number</span> &#125;[] = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;刘英&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;谢大脚&quot;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h4><p>用来表示<strong>混合类型</strong>的<strong>定长</strong>数组</p>
<p>用来表示<strong>已知元素数量和类型的数组</strong>，各元素的类型不必相同，对应位置的类型需要相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [string, number];</span><br><span class="line">x = [<span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1</span>];    <span class="comment">// 运行正常</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="string">&#x27;Runoob&#x27;</span>];    <span class="comment">// 报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">0</span>]);    <span class="comment">// 输出 Runoob</span></span><br></pre></td></tr></table></figure>

<p>元组中的值也可以添加可选符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">optionalTuple</span>: [string, boolean?];</span><br><span class="line">optionalTuple = [<span class="string">&quot;Semlinker&quot;</span>, <span class="literal">true</span>];</span><br><span class="line">optionalTuple = [<span class="string">&quot;Semlinker&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：元组会被自动解析成联合类型，我们需要加上as const变成tuple类型。&amp;#x20;</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/image_YpkHe1jvVR.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/image_CFAAIXk41p.png"></p>
<h4 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum 枚举"></a>enum 枚举</h4><p>枚举类型用于定义数值集合。将所有可能的情况一一列举。可以理解为一组映射关系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">Gender</span>&#123;</span><br><span class="line">  male =<span class="number">0</span>,</span><br><span class="line">  female = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">interface person&#123;</span><br><span class="line">  <span class="attr">name</span>:string,<span class="attr">gender</span>:<span class="title class_">Gender</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:person = &#123;<span class="attr">name</span>:<span class="string">&#x27;xiao&#x27;</span>,<span class="attr">gender</span>:<span class="title class_">Gender</span>.<span class="property">male</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">//&#123;name:&#x27;xiao&#x27;,gender:0&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以<strong>使用字面量的联合类型可以简单替代，但是不容易区分。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>:<span class="number">0</span>|<span class="number">1</span> <span class="comment">//这样的话无法区分0是男还是1是男</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="void-amp-x20"><a href="#void-amp-x20" class="headerlink" title="void&amp;#x20;"></a>void&amp;#x20;</h4><p>用于标识方法返回值的类型，表示该方法<strong>没有返回值</strong>。</p>
<p><code>void</code> 某种程度上来说正好与 <code>any</code> 相反，表示无任何类型，没有类型，如果是函数则应没有返回值或者返回 <code>undefined</code>&amp;#x20;</p>
<h4 id="never-了解"><a href="#never-了解" class="headerlink" title="never (了解)"></a>never (了解)</h4><p>never 表示永远不会发生值的类型。一个永远不会有返回值，例如产生<strong>死循环</strong>的函数或者<strong>抛出异常</strong>，就可以加上never</p>
<ul>
<li><code>never</code>与其他类型的联合后，是没有<code>never</code>的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type T = number | never</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:T = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="any-amp-x20"><a href="#any-amp-x20" class="headerlink" title="any     &amp;#x20;"></a>any     &amp;#x20;</h4><p>声明为 any 的变量可以赋予任意类型的值。（默认值，不推荐使用，因为any是有害的。）</p>
<ul>
<li><p>any可以调用任意方法，</p>
</li>
<li><p>any也可以赋值给任意类型或者被任意类型赋值。</p>
</li>
</ul>
<p>原理：定义为any类型的变量，在编译阶段，则不会对它的类型进行检测，让它直接通过编译阶段。因此any可以<strong>被任意类型赋值</strong>，而any的类型等于赋值的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:any = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:number = <span class="number">1</span> </span><br><span class="line">c=a</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> c )  </span><br><span class="line"><span class="comment">//booble  any可以改变其他数据的类型。 也可以被其他数据类型改变。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: any =<span class="number">4</span> </span><br><span class="line">e.<span class="title function_">func</span>();   <span class="comment">//any可以调用任意方法，执行前不会报错。</span></span><br></pre></td></tr></table></figure>

<h4 id="unknown-amp-x20"><a href="#unknown-amp-x20" class="headerlink" title="unknown&amp;#x20;"></a>unknown&amp;#x20;</h4><p>&amp;#x20;表示未知类型变量。是 <code>typescript 3.0</code> 中引入的新类型。<code>unknown</code> 与 <code>any</code> 类似，但使用前必须进行<strong>断言或守卫</strong>。相较于any更加安全。（当你想用any的时候就可以使用unkonw代替。 ）</p>
<ul>
<li><p>只能<strong>给  或  类型的数据赋值</strong>，赋值给其他类型会出错。</p>
</li>
<li><p><code>unkonwn</code>可以<strong>被任意类型赋值</strong>，其类型等于赋值类型。</p>
</li>
<li><p><strong>不允许执行  类型变量的方法（除非使用类型断言）。</strong></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: unknown = <span class="string">&#x27;notsure&#x27;</span></span><br><span class="line">notSure.<span class="title function_">toString</span>()  <span class="comment">//出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: any = <span class="string">&#x27;notsure&#x27;</span></span><br><span class="line">notSure.<span class="title function_">toString</span>()  <span class="comment">//不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: number = <span class="number">12</span></span><br><span class="line"><span class="attr">number</span>:notSure  <span class="comment">//会报错，不能将unkonw类型数据传给已知的数据类型。</span></span><br><span class="line"><span class="attr">notSure</span>:number  <span class="comment">//但是可以将已知的数据类型传递给unknow类型。</span></span><br><span class="line"></span><br><span class="line">num = any</span><br><span class="line">string = any</span><br><span class="line"></span><br><span class="line">any = notSure</span><br><span class="line">notSure = any</span><br><span class="line"></span><br><span class="line">num = notSure  <span class="comment">//出错</span></span><br><span class="line">string=notSure  <span class="comment">//出错</span></span><br></pre></td></tr></table></figure>

<p>但如果我们要对未知类型执行某些操作，也不是没有办法</p>
<p>方式一：使用<strong>类型断言</strong>(as)缩小未知范围 &amp;#x20;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: unknown = <span class="string">&#x27;sisterAn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((notSure <span class="keyword">as</span> string).<span class="title function_">toLowerCase</span>())</span><br></pre></td></tr></table></figure>

<p>方式二：使用<strong>类型守卫</strong>(type of)进行类型收缩</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: unknown = <span class="string">&#x27;sisterAn&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> notSure === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(notSure.<span class="title function_">toLowerCase</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="object、Object、"><a href="#object、Object、" class="headerlink" title="object、Object、{}"></a>object、Object、{}</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6993971864989073422" title="TypeScript中如何使用Object、object和{}">TypeScript中如何使用Object、object和{}</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1610691" title="一文读懂 TS 中 Object, object, {} 类型之间的区别 - 腾讯云开发者社区-腾讯云 (tencent.com)">一文读懂 TS 中 Object, object, {} 类型之间的区别 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<ul>
<li><p><strong>Object</strong></p>
<p>Object类型是所有 Object 类的实例的类型。它由以下两个接口来定义：</p>
<ul>
<li><p>Object 接口定义了 Object.prototype 原型对象上的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Object</span> &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Function</span>;</span><br><span class="line">  <span class="title function_">toString</span>(): string;</span><br><span class="line">  <span class="title function_">toLocaleString</span>(): string;</span><br><span class="line">  <span class="title function_">valueOf</span>(): <span class="title class_">Object</span>;</span><br><span class="line">  <span class="title function_">hasOwnProperty</span>(<span class="attr">v</span>: <span class="title class_">PropertyKey</span>): boolean;</span><br><span class="line">  <span class="title function_">isPrototypeOf</span>(<span class="attr">v</span>: <span class="title class_">Object</span>): boolean;</span><br><span class="line">  <span class="title function_">propertyIsEnumerable</span>(<span class="attr">v</span>: <span class="title class_">PropertyKey</span>): boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object 类的所有实例都继承了 Object 接口中的所有属性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ObjectConstructor</span> &#123;</span><br><span class="line">  <span class="comment">/** Invocation via `new` */</span></span><br><span class="line">  <span class="title function_">new</span>(value?: <span class="built_in">any</span>): <span class="title class_">Object</span>;</span><br><span class="line">  <span class="comment">/** Invocation via function calls */</span></span><br><span class="line">  (value?: <span class="built_in">any</span>): <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">prototype</span>: <span class="title class_">Object</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getPrototypeOf</span>(<span class="attr">o</span>: <span class="built_in">any</span>): <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="title class_">Object</span>: <span class="title class_">ObjectConstructor</span>;</span><br><span class="line"></span><br><span class="line">作者：阿宝哥</span><br><span class="line">链接：<span class="attr">https</span>:<span class="comment">//juejin.cn/post/6844904170521100296</span></span><br><span class="line">来源：稀土掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Object类型包含了所有的<strong>原始&#x2F;基础</strong>类型，所以可以给Object类型赋值为基础类型；</p>
<p>因为：基础类型使用方法时候会调用其包装类型，而包装类型的原型就是<code>Object.prototype</code>&amp;#x20;</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;semlinker&#x27;</span>.<span class="property">hasOwnProperty</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果值对象属性名与 Object 接口中的属性冲突，则 TypeScript 编译器会提示相应的错误。即重写在 Object 类型上定义的所有属性和方法会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">Object</span>; <span class="comment">// 或者 let obj = new Object();</span></span><br><span class="line">obj = <span class="string">&quot;hell oworld&quot;</span>;</span><br><span class="line">obj = <span class="number">1</span>;</span><br><span class="line">obj = <span class="literal">true</span>;</span><br><span class="line">obj = <span class="literal">undefined</span>; <span class="comment">//Error:Type &#x27;undefined&#x27; is not assignable to type &#x27;Object&#x27;.</span></span><br><span class="line">obj = &#123;</span><br><span class="line">    <span class="comment">// Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;</span></span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;  <span class="comment">//重写了toString方法，返回的是number。</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>**object **</p>
<p>TypeScript 2.2 引⼊的新类型，它⽤于表示<strong>非原始类型</strong>。也就是说我们不能把 number、string、boolean、symbol等 原始类型赋值给 object <strong>。</strong></p>
<p>object类型可以重写在 Object 类型上定义的所有属性和方法。</p>
<p>在严格模式下，<code>null</code> 和 <code>undefined</code> 类型也不能赋给 object。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">lowerCaseObject</span>: object;</span><br><span class="line">lowerCaseObject = <span class="number">1</span>;         <span class="comment">// ts(2322)</span></span><br><span class="line">lowerCaseObject = <span class="string">&#x27;a&#x27;</span>;       <span class="comment">// ts(2322)</span></span><br><span class="line">lowerCaseObject = <span class="literal">true</span>;      <span class="comment">// ts(2322)</span></span><br><span class="line">lowerCaseObject = <span class="literal">null</span>;      <span class="comment">// ts(2322)</span></span><br><span class="line">lowerCaseObject = <span class="literal">undefined</span>; <span class="comment">// ts(2322)</span></span><br><span class="line">lowerCaseObject = &#123;&#125;;        <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>可以使用可选属性和 <code>&#123;[propName:string]:unknow&#125;</code>表示可以添加其他任意属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:object;</span><br><span class="line"></span><br><span class="line">a = &#123;&#125;  <span class="comment">//对象</span></span><br><span class="line">a = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;  <span class="comment">//函数对象</span></span><br><span class="line">a = []</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a :&#123;</span><br><span class="line">  <span class="attr">name</span>:string,</span><br><span class="line">  <span class="attr">age</span>:number,</span><br><span class="line">  [<span class="attr">propName</span>:string]:string |number  </span><br><span class="line">  <span class="comment">//[propName:string]:string   写成这样age会报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在处理 object 类型和字符串索引对象类型的赋值操作时，要特别注意</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">strictTypeHeaders</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">header</span>: <span class="built_in">object</span> = &#123;&#125;;</span><br><span class="line">header = strictTypeHeaders; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Type &#x27;object&#x27; is not assignable to type &#x27;&#123; [key: string]: string; &#125;&#x27;.</span></span><br><span class="line">strictTypeHeaders = header; <span class="comment">// Error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后一行会出现编译错误，这是因为 <code>&#123; [key: string]: string &#125;</code> 类型相比 <code>object</code> 类型更加精确。而 <code>header = strictTypeHeaders;</code> 这一行却没有提示任何错误，是因为这两种类型都是非基本类型，<code>object</code> 类型比 <code>&#123; [key: string]: string &#125;</code> 类型更加通用。</p>
</li>
<li><p><strong>{ }</strong></p>
<p>{}代表没有成员的空对象。等价于没有属性的object。但仍然可以使用在 Object 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用.</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904170521100296" title="https://juejin.cn/post/6844904170521100296">https://juejin.cn/post/6844904170521100296</a></p>
</li>
</ul>
<h1 id="二-断言-类型守卫"><a href="#二-断言-类型守卫" class="headerlink" title="二,断言 类型守卫"></a>二,断言 类型守卫</h1><h2 id="1-类型推断"><a href="#1-类型推断" class="headerlink" title="1.类型推断"></a>1.类型推断</h2><p>类型推断：ts会自动尝试分析变量的类型。具有初始化值的变量、有默认值的函数参数、函数返回的类型都可以根据上下文推断出来。<strong>注意区分字面量</strong>。</p>
<p><strong>类型推断并不可靠</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> countInference = 1q23  <span class="comment">//类型推断为number</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-非空断言"><a href="#2-非空断言" class="headerlink" title="2.非空断言"></a>2.非空断言</h2><p>后缀表达式操作符 <code>!</code> 可以用于断言操作对象是非 null 和非 undefined 类型。<strong>具体而言，x! 将从 x 值域中排除 null 和 undefined 。</strong></p>
<h2 id="3-类型断言"><a href="#3-类型断言" class="headerlink" title="3.类型断言"></a>3.类型断言</h2><p>告诉解析器变量的实际类型。通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。</p>
<p>类型断言有两种形式。&amp;#x20;</p>
<p>一种是“尖括号”语法，不推荐，这会与 JSX 的语法存在歧义&lt;foo&gt;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: any = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: number = (&lt;string&gt;someValue).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>另一个为<code>as</code>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: any = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: number = (someValue <span class="keyword">as</span> string).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-类型守卫"><a href="#4-类型守卫" class="headerlink" title="4.类型守卫"></a>4.类型守卫</h2><p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</p>
<ul>
<li><p>&amp;#x20;typeof   (js)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> person.<span class="property">age</span> === <span class="string">&quot;string&quot;</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、类型的一些概念"><a href="#三、类型的一些概念" class="headerlink" title="三、类型的一些概念"></a>三、类型的一些概念</h1><h2 id="1-联合类型-（或）"><a href="#1-联合类型-（或）" class="headerlink" title="1.  |  联合类型   （或）"></a>1.  |  联合类型   （或）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myNumber</span>: string | number </span><br></pre></td></tr></table></figure>

<h2 id="2-amp-交叉类型-（且）"><a href="#2-amp-交叉类型-（且）" class="headerlink" title="2. &amp; 交叉类型    （且）"></a>2. &amp; 交叉类型    （且）</h2><ol>
<li><p>同名基础类型属性<strong>取交集</strong>，如果没有交集返回never</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type a = &#123;<span class="attr">id</span>:string | number&#125;</span><br><span class="line">type b = &#123;<span class="attr">id</span>:number&#125;</span><br><span class="line">type c = &#123;<span class="attr">id</span>:boolean&#125;</span><br><span class="line">type t = a&amp;b   <span class="comment">//&#123; id:number &#125;</span></span><br><span class="line">type t = a&amp;c   <span class="comment">//&#123; id:never&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同名非基础类型，<strong>取并集</strong>，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;<span class="attr">d</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;<span class="attr">e</span>:string&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface C &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;<span class="attr">e</span>:number&#125;,</span><br><span class="line">&#125;</span><br><span class="line">type <span class="variable constant_">ABC</span> = A &amp; B &amp; C</span><br><span class="line"><span class="keyword">let</span> <span class="attr">abc</span>:<span class="variable constant_">ABC</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:&#123;</span><br><span class="line">    <span class="attr">d</span>:<span class="literal">true</span>, </span><br><span class="line">    <span class="comment">// e:1  // 报错 never</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-类型别名-type"><a href="#3-类型别名-type" class="headerlink" title="3.类型别名 type"></a>3.类型别名 type</h2><p>定义对象数组时候，定义这么长的数据比较麻烦，且结构不清晰，我们可以使用<code>类型别名</code>(type alias) 关键字 <code>type</code>来代替声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Lady</span> = &#123; <span class="attr">name</span>: string, <span class="attr">age</span>: <span class="title class_">Number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">xiaoJieJies</span>: <span class="title class_">Lady</span>[] = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;刘英&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;谢大脚&quot;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;name&#x27;</span>,<span class="number">1</span>&#125;, <span class="comment">//注意不能写成这样</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="4-类型扩宽"><a href="#4-类型扩宽" class="headerlink" title="4.类型扩宽"></a>4.类型扩宽</h2><p>所有通过 let 或 var 定义的<strong>非只读属性</strong>，如果<strong>指定了初始值</strong>(字面量) 且** 未显式添加类型注解**，那么它们推断出来的类型就是指定的<strong>初始值字面量类型拓宽后的类型</strong> （const没有类型扩宽）</p>
<ol>
<li><p>基础类型的字面量会扩宽为基础类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str类型是 string， 因为未显式声明类型注解,且被指定了初始值。类型拓宽为 string</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;this is string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型是 (str?: string) =&gt; string;</span></span><br><span class="line"><span class="comment">// str 被赋予了一个默认值，如果没有传入就是默认值，因此str必然是可选的。</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">strFun</span> = (<span class="params">str = <span class="string">&#x27;this is string&#x27;</span></span>) =&gt; str; </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 类型是 &#x27;this is string&#x27;，常量不可变更，类型没有拓宽，</span></span><br><span class="line"><span class="keyword">const</span> specifiedStr = <span class="string">&#x27;this is string&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> str2 = specifiedStr; <span class="comment">// 类型是 &#x27;string&#x27; </span></span><br><span class="line"><span class="comment">//注意尽管赋值的是const类型，但是被扩宽为string,</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>元组类型会被扩宽为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;x&#x27;</span>, <span class="number">1</span>]; <span class="comment">//类型会被扩宽成为  (string | number)[]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="限制扩宽"><a href="#限制扩宽" class="headerlink" title="限制扩宽"></a>限制扩宽</h3><ol>
<li><p>显式指定字面量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以添加显式类型注解控制类型拓宽行为  类型是 &#x27;&quot;this is string&quot;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">specifiedStr</span>: <span class="string">&#x27;this is string&#x27;</span> = <span class="string">&#x27;this is string&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> str2 = specifiedStr</span><br><span class="line">str2 =<span class="string">&#x27;other&#x27;</span>  <span class="comment">//显式类型注解，指定扩宽行为。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用const 声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="string">&#x27;x&#x27;</span>|<span class="string">&#x27;y&#x27;</span>|<span class="string">&#x27;z&#x27;</span> </span><br><span class="line"><span class="keyword">let</span> b =<span class="string">&#x27;x&#x27;</span>   <span class="comment">// b被扩宽成了string类型。会报错。  </span></span><br><span class="line"><span class="comment">// const b = &#x27;x&#x27;</span></span><br><span class="line"><span class="comment">// let b =&#x27;x&#x27;   as const</span></span><br><span class="line">a=b</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用as const&amp;#x20;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//元组会被扩宽成数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;x&#x27;</span>, <span class="number">1</span>]; <span class="comment">//类型会被扩宽成为  (string | number)[]</span></span><br><span class="line"><span class="comment">//使用  const arr = [&#x27;x&#x27;, 1] as const</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>对象中的属性会拓宽内部属性视为将其赋值给 let 关键字声明的变量，进而来推断其属性的类型。</p>
<p>例如下面代码中obj中x相当于（let x &#x3D;1），因此x的类型是number。&amp;#x20;</p>
<p>此外它还会阻止你添加其他属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">obj.<span class="property">x</span> = <span class="number">6</span>;   <span class="comment">//正确</span></span><br><span class="line">obj.<span class="property">x</span> = <span class="string">&#x27;6&#x27;</span>;  <span class="comment">//报错：不能将string赋值给number</span></span><br><span class="line">obj.<span class="property">y</span> = <span class="number">8</span>;    <span class="comment">//报错，obj没有y属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用const 断言，readonly的实现。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Type</span> is &#123; readonly <span class="attr">x</span>: <span class="number">1</span>; readonly <span class="attr">y</span>: <span class="number">2</span>; &#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>, </span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span> </span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-标签联合（可辨识联合）"><a href="#5-标签联合（可辨识联合）" class="headerlink" title="5.标签联合（可辨识联合）"></a>5.标签联合（可辨识联合）</h2><p>TypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。<strong>它包含 3 个要点：可辨识、联合类型和类型守卫。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">UploadEvent</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;upload&quot;</span>;</span><br><span class="line">  <span class="attr">filename</span>: string;</span><br><span class="line">  <span class="attr">contents</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">DownloadEvent</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;download&quot;</span>;</span><br><span class="line">  <span class="attr">filename</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">AppEvent</span> = <span class="title class_">UploadEvent</span> | <span class="title class_">DownloadEvent</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEvent</span>(<span class="params">e: AppEvent</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;download&quot;</span>:</span><br><span class="line">      e; <span class="comment">// Type is DownloadEvent </span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;upload&quot;</span>:</span><br><span class="line">      e; <span class="comment">// Type is UploadEvent </span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h1><h2 id="1-函数类型"><a href="#1-函数类型" class="headerlink" title="1.函数类型"></a>1.函数类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span> (<span class="attr">name</span>: string, <span class="attr">id</span>: number): string &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>  createUserId = (<span class="attr">name</span>: string, <span class="attr">id</span>: number): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-函数重载"><a href="#2-函数重载" class="headerlink" title="2.函数重载"></a>2.函数重载</h2><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。</p>
<p>方法签名：<strong>方法签名是一个方法在一个类中的唯一标识</strong>，由<strong>方法名 + 参数类型及其排列</strong>组成。&amp;#x20;</p>
<p>​<strong>不属于方法签名。</strong>同一个类方法中，方法名可以重复，方法签名不可以重复。如果一个类中定义了<strong>方法名相同，签名不同的方法，就叫方法的重载</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/image_as8EEl-hSs.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载签名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">person:string</span>):string;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">person:string[]</span>):string[];</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现签名的函数。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">person:unknown</span>):unknow&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> person ===<span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;person&#125;</span>!`</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(person))&#123;</span><br><span class="line">    <span class="keyword">return</span> person.<span class="title function_">map</span>(<span class="function">(<span class="params">name</span>)=&gt;</span><span class="string">`hello,<span class="subst">$&#123;name&#125;</span>!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;unable to greet&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-this指向（了解）"><a href="#3-this指向（了解）" class="headerlink" title="3. this指向（了解）"></a>3. this指向（了解）</h2><p>原生JS中的this指向非常模糊，函数中的this只有当函数被调用了才能知道this指向谁。而TS中，<strong>严格模式下必须显式地指定this指向</strong>，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="variable language_">this</span>: Window, str: string</span>)&#123;    <span class="comment">// 这里Window是大写</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">fn</span> = fn;      <span class="comment">// 这里window是小写</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">fn</span>(<span class="string">&quot;你好世界&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里要注意：</p>
<p>1、这段代码不会成功执行，因为你是在ts-node环境下运行，不存在window，也不会有global；</p>
<p>2、这里的this是伪形参，不会被编译为js。</p>
<h1 id="五、接口"><a href="#五、接口" class="headerlink" title="五、接口"></a>五、接口</h1><p>在typescript中，接口有两种概念，ts除了可用于对类的一部分行为进行抽象以外，也常用于对<strong>对象的形状</strong>进行描述。<strong>接口一般首字母大写。</strong></p>
<p><strong>第一种：对对象的形状（必须包含的属性和方法）的描述。</strong>（鸭子类型：对象推断策略）把接口的看作是一个实际的东西。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printName</span>(<span class="params">person:Person</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种</strong>：概念和面向对象编程有关，对class进行抽象。<strong>接口就是规定要程序做什么，但不在其中实现。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Radio</span>&#123;</span><br><span class="line">  <span class="title function_">changeRadio</span>(<span class="attr">pingdao</span>:number):boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口中的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> implement <span class="title class_">Radio</span>&#123;</span><br><span class="line">  <span class="title function_">changeRadio</span>(<span class="attr">pingdao</span>:number):boolean&#123;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口是对行为的抽象，是一种约束，而具体如何实现需要由类去实现。</p>
<p><strong>接口中所有的（属性、方法）都不能有实际的值</strong>，接口只定义对象的结构，而不考虑实际值。</p>
<p><strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。理解：就像usb接口， 规定了是长方形就不能改变其形状，否则插不进去。</p>
<h2 id="1-接口的用法"><a href="#1-接口的用法" class="headerlink" title="1.接口的用法"></a>1.接口的用法</h2><p>接口用来定义一个类的结构,定义一个类中应该包含哪些属性和方法。接口也可以当作类型声明去使用 （type）,</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Person</span> &#123;</span><br><span class="line">  readonly <span class="attr">name</span>: string;   <span class="comment">//只读</span></span><br><span class="line">  age?: number;   <span class="comment">//可选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-interface-和type的区别："><a href="#1-interface-和type的区别：" class="headerlink" title="1.interface 和type的区别："></a>1.interface 和type的区别：</h3><blockquote>
<p>1.<strong>interface 可以重复声明</strong>，重复声明的接口属性取<strong>并集</strong>，而type是一种别名，不能重复声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface myInterface&#123;  </span><br><span class="line">  <span class="attr">name</span>:string;</span><br><span class="line">  <span class="attr">age</span>:number</span><br><span class="line">&#125;</span><br><span class="line">interface myInterface&#123;</span><br><span class="line">  <span class="attr">sex</span>:string</span><br><span class="line">  <span class="comment">//age:string 同名的属性不同值会报错。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>:myInterface=&#123;  <span class="comment">//必须要实现3个属性</span></span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;sss&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">12</span>,</span><br><span class="line">  <span class="attr">sex</span>:<span class="string">&#x27;man&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于type s = myInterface1 &amp; myInterface2 </span></span><br></pre></td></tr></table></figure>

<p>2.interface不能使用联合类型 | ，而type可以使用联合类型。因此是<strong>定义非对象类型，通常使用type,对象类型使用interface。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type newType = string | number <span class="comment">//使用联合</span></span><br><span class="line"><span class="comment">// interface 也没有办法实现utility typE</span></span><br></pre></td></tr></table></figure>

<p>3.定义函数时 type使用 &#x3D;&gt; 表示返回值，而interface使用 ：表示返回值。</p>
<p>4.接口的扩展就是继承，通过 <code>extends</code> 来实现。类型别名的扩展就是交叉类型，通过 <code>&amp;</code> 来实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">SetPoint</span> = <span class="function">(<span class="params">x: number, y: number</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">SetPoint</span> &#123;</span><br><span class="line">  (<span class="attr">x</span>: number, <span class="attr">y</span>: number): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-接口和抽象类的区别："><a href="#2-接口和抽象类的区别：" class="headerlink" title="2.接口和抽象类的区别："></a>2.接口和抽象类的区别：</h3><ol>
<li><p>抽象类中，可以有<strong>实质（普通，不需要重写，实例可以直接用）的方法，也可以有抽象方法</strong>（必须重写），而接口中全部是抽象方法（不实现的方法，需要重写）</p>
</li>
<li><p>抽象类使用的是extends  接口使用的是implement</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用接口定义字段类型</span></span><br><span class="line"><span class="comment">// 接口一般首字母大写，经常使用I开头</span></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IMyInter</span>&#123;</span><br><span class="line">  <span class="attr">name</span>:string;</span><br><span class="line">  <span class="title function_">sayName</span>():<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类时，可以去实现一个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myClass</span> implements <span class="title class_">IMyInter</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">public name:string</span>)&#123;&#125;</span><br><span class="line">  <span class="title function_">sayName</span>(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-索引签名"><a href="#3-索引签名" class="headerlink" title="3. 索引签名"></a>3. 索引签名</h3><p><strong>索引签名</strong>：<strong>允许在接口中指定所有的<strong><strong>属性</strong></strong>的 键和值类型。</strong></p>
<p>例如：  <code>&#123;[key: string]: number&#125;</code> 是一种索引签名，它告诉TypeScript 该接口的<strong>所有属性</strong>必须是一个以<code>string</code> 类型为键，以 <code>number</code> 类型为值的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: string;</span><br><span class="line">    age?: number;               <span class="comment">// 会报错，因为age不是string类型</span></span><br><span class="line">    [<span class="attr">propName</span>: string]:stinrg   <span class="comment">// 一般定义为unknow，或者联合类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ts支持两种签名，一种是数字索引，一种是字符串索引</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">StringArray</span> &#123;</span><br><span class="line">  <span class="comment">// 字符串索引 -&gt; keyof StringArray =&gt; string | number</span></span><br><span class="line">  [<span class="attr">index</span>: string]: string; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">StringArray1</span> &#123;</span><br><span class="line">  <span class="comment">// 数字索引 -&gt; keyof StringArray1 =&gt; number</span></span><br><span class="line">  [<span class="attr">index</span>: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-鸭式辨形法"><a href="#6-鸭式辨形法" class="headerlink" title="6.鸭式辨形法"></a>6.鸭式辨形法</h3><p>通过制定规则来判定对象是否实现这个接口，如果实现了接口中的属性就可以接收。</p>
<p>例如，定义一个Duck的接口，定义了swim,foots,cry方法，就是定义了规则，创建检测方法，用来检测对象中有没有实现Duck接口中所有的方法，如果有就认为实现了这个方法，否则就没有实现。如果人会swim,foots,cry的类型实现了这些方法，也会被当作是鸭子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Duck</span> &#123;</span><br><span class="line">  <span class="attr">swim</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isDuck</span>(<span class="params">duck:Duck</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(duck);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> duck1 = &#123; <span class="attr">swim</span>:<span class="string">&#x27;yes&#x27;</span>, <span class="attr">age</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isDuck</span>(duck1); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">isDuck</span>(&#123; <span class="attr">swim</span>:<span class="string">&#x27;yes&#x27;</span>, <span class="attr">age</span>:<span class="number">1</span>&#125;); <span class="comment">// Error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在函数参数中直接定义对象就相当于是直接给Duck类型赋值，这个对象有严格的类型定义，所以不能多参或少参。</p>
<p><strong>而当在外面将该对象用另一个变量myObj接收，duck不会经过额外属性检查</strong>，而duck1再赋值给形参duck，<strong>此时根据类型的兼容性，两种类型对象，参照鸭式辨型法</strong>，因为都具有swim属性，所以被认定为两个相同，故而可以用此法来绕开多余的类型检查。</p>
</blockquote>
<h1 id="六、类"><a href="#六、类" class="headerlink" title="六、类"></a>六、类</h1><p>面向对象（oop）: 封装（不暴露具体实现细节。通过修饰符），继承（继承父类属性和方法），多态（重写方法）</p>
<h2 id="1-修饰符"><a href="#1-修饰符" class="headerlink" title="1.修饰符"></a>1.修饰符</h2><p>&amp;#x20;TypeScript 中就支持 3 种访问修饰符，分别是 public、private、protected。</p>
<h3 id="public-默认"><a href="#public-默认" class="headerlink" title="public 默认"></a>public 默认</h3><p>public 修饰的属性可以在任意位置（实例，类中，子类中）访问或修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: string;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: string</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayName</span>():<span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">animal.<span class="title function_">sayName</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码相当于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    public <span class="attr">name</span>: string;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: string</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="title function_">sayName</span>():<span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">animal.<span class="title function_">sayName</span>();</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="private-amp-x20"><a href="#private-amp-x20" class="headerlink" title="private&amp;#x20;"></a>private&amp;#x20;</h3><p>private 修饰的是<strong>仅在当前类中可见，（子类和实例不可见），通常用来定义私有的属性或方法</strong>。私有属性一般会前面加’ _‘ 。</p>
<p>可以通过<strong>定义实例方法</strong>去访问私有属性。也可以通过getter,setter 访问器 设置器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  public <span class="attr">name</span>: string;</span><br><span class="line">  private <span class="attr">_age</span>: number;  <span class="comment">// 只能在当前类中使用，实例和子类不能直接访问</span></span><br><span class="line">  private <span class="attr">_sex</span>: string; <span class="comment">// 只能在当前类中使用，实例和子类不能直接访问</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number, sex:string</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_age</span> = age;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_sex</span> = sex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">age</span>():number&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">age:number</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;改变了年龄&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_age</span> = age; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="title function_">sayName</span>():<span class="keyword">void</span>&#123;</span><br><span class="line">                            <span class="comment">//这里age通过getter访问    //这里sex直接通过属性</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>今年<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>岁,<span class="subst">$&#123;<span class="variable language_">this</span>._sex&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">11</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">animal.<span class="title function_">sayName</span>();    </span><br><span class="line">animal.<span class="property">age</span>=<span class="number">12</span>       <span class="comment">// 张三今年11岁</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(animal.<span class="property">age</span>);    <span class="comment">// 通过getter间接访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(animal.<span class="property">_sex</span>); <span class="comment">//报错 属性“_sex”为私有属性，只能在类中访问。</span></span><br></pre></td></tr></table></figure>

<p>在 TypeScript 3.8 版本开始支持<strong>ECMAScript 私有字段</strong>标识符 #，使用方式如下：</p>
<ul>
<li>私有字段以 <code>#</code> 字符开头，有时我们称之为私有名称；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #<span class="attr">name</span>: string;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.#name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Semlinker&quot;</span>);</span><br><span class="line">semlinker.#name;   <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h3 id="protected-amp-x20"><a href="#protected-amp-x20" class="headerlink" title="protected&amp;#x20;"></a>protected&amp;#x20;</h3><p>受保护的属性，能在类和子类中进行访问，不能在实例中访问。</p>
<h3 id="static-amp-x20"><a href="#static-amp-x20" class="headerlink" title="static&amp;#x20;"></a>static&amp;#x20;</h3><p>静态属性，类属性，类方法，通过类访问，不能通过实例访问。</p>
<h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code>来指定只读属性。</p>
<p>**as const 可以实现readonly **</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Point</span> &#123;</span><br><span class="line">    readonly <span class="attr">x</span>: number;</span><br><span class="line">    readonly <span class="attr">y</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.<span class="property">x</span> = <span class="number">5</span>; <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>readonly</code> vs <code>const</code></p>
<p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它当作<strong>变量使用还是做为一个属性。</strong> 做为变量使用的话用 <code>const</code>，若做为属性则使用<code>readonly</code>。</p>
<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p><strong>抽象类无法被实例化。</strong></p>
<p>例如创建animal类，dog、cat继承animal,而animal是一个基类（超类）,因此不希望它能够实例化。因此可以加上一个abstract 表明它是一个抽象类。</p>
<p><strong>抽象类和其他类区别不大，只是不能被实例化。</strong></p>
<p>抽象类就是被用来继承的类。</p>
<p><strong>抽象方法</strong>（必须被子类重写）</p>
<p>例如不同的动物叫法不一样，因此子类继承父类的方法中的具体实现没有意义，因此<strong>抽象方法可以将方法的结构定义出来，不去实现。要求由子类去具体实现</strong>。</p>
<p>&#x2F;&#x2F; 抽象方法只能定义在抽象类中，子类必须对抽象方法重写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">  <span class="attr">name</span>:string  <span class="comment">//必须要先声明，否者this中的name不会生效。</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abstract <span class="title function_">sayHello</span>():<span class="keyword">void</span>  <span class="comment">//必须指定抽象函数返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;</span><br><span class="line">  <span class="attr">age</span>:number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:string,age:number</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;汪汪汪&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="七、泛型-Generics"><a href="#七、泛型-Generics" class="headerlink" title="七、泛型 Generics"></a>七、泛型 Generics</h1><p>泛型是指在定义<strong>函数、接口，或者类</strong>，类型别名 等时候，<strong>不预先指定具体的类型，而是在使用的时候在指定类型的一种特性。</strong> 可以看作是一个类型的占位符，使用的时候动态传入值。</p>
<p>使用场景：根据输入元素的类型，使输出元素类型相同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无法复用。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a:number</span>):number&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-泛型简单使用"><a href="#1-泛型简单使用" class="headerlink" title="1.泛型简单使用"></a>1.泛型简单使用</h2><p>泛型可以用任意字母表示，但是我们约定俗成：</p>
<ul>
<li><p>T（type）  表示类型</p>
</li>
<li><p>K（key) 表示对像中键的类型</p>
</li>
<li><p>V（value）表示对象中值的类型</p>
</li>
<li><p>E（element）表示元素类型</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/image_kJ3Rkus_UR.png"></p>
<h3 id="函数指定泛型"><a href="#函数指定泛型" class="headerlink" title="函数指定泛型"></a>函数指定泛型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> test&lt;T&gt;(<span class="attr">value</span>:T):T&#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类指定泛型"><a href="#类指定泛型" class="headerlink" title="类指定泛型"></a>类指定泛型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&lt;T&gt;&#123;</span><br><span class="line">  private  <span class="attr">data</span>:T[] = [];</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">item:t</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实例：</span></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;number&gt;()  <span class="comment">//使用时需要指定。</span></span><br><span class="line">queue.<span class="title function_">push</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="接口指定泛型"><a href="#接口指定泛型" class="headerlink" title="接口指定泛型"></a>接口指定泛型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface keyPair&lt;T,U&gt;&#123;</span><br><span class="line">  <span class="attr">key</span>:T;</span><br><span class="line">  <span class="attr">value</span>:U;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-同时指定多个泛型"><a href="#2-同时指定多个泛型" class="headerlink" title="2.同时指定多个泛型"></a>2.同时指定多个泛型</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/image_ogBxPR9kcc.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity &lt;T, U&gt;(<span class="attr">value</span>: T, <span class="attr">message</span>: U) : T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(identity&lt;<span class="title class_">Number</span>, string&gt;(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-泛型约束-extends"><a href="#3-泛型约束-extends" class="headerlink" title="3.泛型约束 extends"></a>3.泛型约束 extends</h2><p><strong>泛型约束：使泛型必须拥有某些属性，通过extends interface实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T可以是任何拥有size属性的对象。</span></span><br><span class="line"><span class="keyword">function</span> trace&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">size</span>); </span><br><span class="line">  <span class="keyword">return</span> arg;  <span class="comment">// Error: Property &#x27;size doesn&#x27;t exist on type &#x27;T&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现：泛型约束</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Sizeable</span> &#123;</span><br><span class="line">  <span class="attr">size</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> trace&lt;T <span class="keyword">extends</span> <span class="title class_">Sizeable</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">size</span>);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-泛型工具类型-utility-types"><a href="#4-泛型工具类型-utility-types" class="headerlink" title="4.泛型工具类型 utility types"></a>4.泛型工具类型 utility types</h2><h3 id="1-类型兼容性"><a href="#1-类型兼容性" class="headerlink" title="1. 类型兼容性"></a>1. 类型兼容性</h3><p><strong>子类型比父类型更加具体, 父类型比子类型更宽泛。具体的可以赋值给更宽泛的类型。</strong></p>
<ol>
<li><p>子类型和可以extends父类型    <code>子 extends 父 </code></p>
</li>
<li><p>父类型被子类型赋值   <code>父  =  子</code>。</p>
</li>
</ol>
<ul>
<li><p>可赋值性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">break</span>(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Animal</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以赋值，子类型更佳具体，可以赋值给更佳宽泛的父类型</span></span><br><span class="line">a = b;</span><br><span class="line"><span class="comment">// 反过来不行</span></span><br><span class="line">b = a;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>可赋值性在联合类型中的特性</p>
<p><code>A</code>此处类型更多但是其表达的类型更宽泛，所以<code>A</code>是父类型，<code>B</code>是子类型。因此<code>b = a</code>不成立（父类型不能赋值给子类型），而<code>a = b</code>成立（子类型可以赋值给父类型）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type A = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line">type B = <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: A;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: B;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可赋值</span></span><br><span class="line">b = a;</span><br><span class="line"><span class="comment">// 可以赋值</span></span><br><span class="line">a = b;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>逆变和协变</p>
<p>结构之间兼容：我要的你都有，那我兼容你 &amp;#x20;<br>函数之间兼容：你给我太多我处理不了啊，我不能兼容你</p>
<h4 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h4><p>具有父子关系的多个类型，在通过某种构造关系构造成的新的类型，如果还具有父子关系则是<strong>协变</strong>的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">break</span>(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Eg1</span>: <span class="title class_">Animal</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Eg2</span>: <span class="title class_">Dog</span>;</span><br><span class="line"><span class="comment">// 兼容，可以赋值</span></span><br><span class="line"><span class="title class_">Eg1</span> = <span class="title class_">Eg2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Eg3</span>: <span class="title class_">Animal</span>[]</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Eg4</span>: <span class="title class_">Dog</span>[]</span><br><span class="line"><span class="comment">// 兼容，可以赋值</span></span><br><span class="line"><span class="title class_">Eg3</span> = <span class="title class_">Eg4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过<code>Eg3</code>和<code>Eg4</code>来看，在<code>Animal</code>和<code>Dog</code>在变成数组后，<code>Array&lt;Dog&gt;</code>依旧可以赋值给<code>Array&lt;Animal&gt;</code>，因此对于<code>type MakeArray = Array&lt;any&gt;</code>来说就是协变的。</p>
<h4 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h4><p>具有父子关系的多个类型，在函数中作为参数，则函数的继承关系是相反的。</p>
<p>举个例子，A只能处理string, B能处理string,number,boolean 。A的参数是B参数的父类型，但是</p>
<p>B却是A的子类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">A</span> = (<span class="params">str:string</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">B</span>=(<span class="params">str: string | number | boolean</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> str)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span> :</span><br><span class="line">      <span class="keyword">return</span> str.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [str.<span class="title function_">toString</span>()];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span> :</span><br><span class="line">      <span class="keyword">return</span> [str.<span class="title function_">toString</span>()];</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>( <span class="string">&#x27;splitstringByDot: type is not string&#x27;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A = B   <span class="comment">// B函数可以直接赋值A， 尽管A中参数str是B的str父类</span></span><br><span class="line"></span><br><span class="line">type C = <span class="keyword">typeof</span> B <span class="keyword">extends</span> <span class="keyword">typeof</span> A ? <span class="literal">true</span> :<span class="literal">false</span>   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="双向协变"><a href="#双向协变" class="headerlink" title="双向协变"></a>双向协变</h4><p>逆变(Contravariance)与双变(Bivariance)只针对函数有效。在tsconfig.json中设置 “strictFunctionTypes ”为true时只支持逆变，false时双变。子能赋值给父，父能赋值给子。</p>
<p>Ts在函数参数的比较中实际上默认采取的策略是双向协变，这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息（典型的就是上述的逆变）</p>
<h3 id="2-extends-amp-x20"><a href="#2-extends-amp-x20" class="headerlink" title="2.extends&amp;#x20;"></a>2.extends&amp;#x20;</h3><p>extends 主要作用有如下三种：</p>
<ol>
<li><p>继承（接口，类）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="variable constant_">T1</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="variable constant_">T2</span> &#123;</span><br><span class="line">  <span class="attr">sex</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承，逗号隔开</span></span><br><span class="line">interface <span class="variable constant_">T3</span> <span class="keyword">extends</span> <span class="variable constant_">T1</span>,<span class="variable constant_">T2</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">t3</span>: <span class="variable constant_">T3</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>约束泛型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Sizeable</span> &#123;</span><br><span class="line">  <span class="attr">size</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> trace&lt;T <span class="keyword">extends</span> <span class="title class_">Sizeable</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">size</span>);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件判断</p>
<p>类似于三目运算符。<strong>如果extends前面的类型能够赋值给extends后面的类型，那么表达式判断为真，否则为假</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type <span class="variable constant_">A2</span> = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;   <span class="comment">//type A2 = true</span></span><br><span class="line"></span><br><span class="line">type P&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;   <span class="comment">//type A3 = true | false</span></span><br><span class="line">type <span class="variable constant_">A3</span> = P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt; </span><br></pre></td></tr></table></figure>

<p>为什么<code>A2</code>和<code>A3</code>的值不一样？</p>
<ul>
<li><p>如果用于简单的条件判断，则是<strong>直接判断前面的类型是否可分配(被继承)给后面的类型</strong>。</p>
</li>
<li><p>若<code>extends</code>前面的<strong>类型是泛型，且泛型传入的是联合类型时，则会分解（依次遍历所有的子类型进行条件判断）联合类型进行判断。然后将最终的结果组成新的联合类型。</strong></p>
</li>
<li><p><strong>如果不想被分解（分发），做法也很简单，可以通过简单的元组类型包裹</strong>。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type P&lt;T&gt; = T <span class="keyword">extends</span> [<span class="string">&#x27;x&#x27;</span>] ? <span class="number">1</span> : <span class="number">2</span>;   <span class="comment">//type A3 = 1 | 2</span></span><br><span class="line">type <span class="variable constant_">A3</span> = P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:<span class="variable constant_">A3</span> =<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-infer"><a href="#3-infer" class="headerlink" title="3. infer"></a>3. infer</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三目运算</span></span><br><span class="line">T <span class="keyword">extends</span> U ? X : Y;</span><br></pre></td></tr></table></figure>

<p>如果占位符类型<code>U</code>是一个可以被<strong>分解成几个部分的类型，譬如数组类型</strong>，元组类型，函数类型，字符串字面量类型等。这时候可以<strong>通过</strong>​<strong>来获取****类型中某个部分的类型。</strong> ​</p>
<p><code>infer</code>语法的限制如下：</p>
<ol>
<li><p><code>infer</code>只能在条件类型的 extends 子句中使用</p>
</li>
<li><p><code>infer</code>得到的类型只能在extends为true语句中使用, 即<code>X</code>中使用。</p>
</li>
<li><p><code>infer</code>推导的名称相同并且都处于<strong>逆变</strong>的位置，则推导的结果将会是<strong>交叉类型</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Bar</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">&#125; ? U : never;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T1 = string</span></span><br><span class="line">type <span class="variable constant_">T1</span> = <span class="title class_">Bar</span>&lt;&#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: string</span>) =&gt;</span> <span class="keyword">void</span>; <span class="attr">b</span>: <span class="function">(<span class="params">x: string</span>) =&gt;</span> <span class="keyword">void</span> &#125;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T2 = never</span></span><br><span class="line">type <span class="variable constant_">T2</span> = <span class="title class_">Bar</span>&lt;&#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: string</span>) =&gt;</span> <span class="keyword">void</span>; <span class="attr">b</span>: <span class="function">(<span class="params">x: number</span>) =&gt;</span> <span class="keyword">void</span> &#125;&gt;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>infer</code>推导的名称相同并且都处于<strong>协变</strong>的位置，则推导的结果将会是<strong>联合类型</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Foo</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: infer U;</span><br><span class="line">  <span class="attr">b</span>: infer U;</span><br><span class="line">&#125; ? U : never;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T1 = string</span></span><br><span class="line">type <span class="variable constant_">T1</span> = <span class="title class_">Foo</span>&lt;&#123; <span class="attr">a</span>: string; <span class="attr">b</span>: string &#125;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T2 = string | number</span></span><br><span class="line">type <span class="variable constant_">T2</span> = <span class="title class_">Foo</span>&lt;&#123; <span class="attr">a</span>: string; <span class="attr">b</span>: number &#125;&gt;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-typeof-amp-x20"><a href="#4-typeof-amp-x20" class="headerlink" title="4. typeof&amp;#x20;"></a>4. typeof&amp;#x20;</h3><ul>
<li><p>typeof 用来获取<strong>变量或对象</strong>的类型。<strong>需要使用类型别名接收。</strong></p>
</li>
<li><p>TS 中的typeof，是在静态环境运行的 。JS中的typeof，是在runtime时运行的。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  <span class="attr">b</span>:string  = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//typeof后跟变量或对象，返回类型。</span></span><br><span class="line">type a = <span class="keyword">typeof</span> b</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  <span class="attr">age</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">sem</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;semlinker&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line">type <span class="title class_">Sem</span> = <span class="keyword">typeof</span> sem; <span class="comment">// type Sem = Person</span></span><br></pre></td></tr></table></figure>

<h3 id="5-keyof-索引查询"><a href="#5-keyof-索引查询" class="headerlink" title="5. keyof  索引查询"></a>5. keyof  索引查询</h3><p>对应任何<strong>类型</strong><code>T</code> （T一般是对象类型）,<code>keyof T</code>的结果为该类型上所有<strong>公有属性key的联合类型</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Person</span> &#123;<span class="attr">name</span>: string;<span class="attr">age</span>: number;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意keyof后跟类型，返回联合类型。</span></span><br><span class="line">type <span class="variable constant_">K1</span> = keyof <span class="title class_">Person</span>; <span class="comment">// &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line">type <span class="variable constant_">K2</span> = keyof <span class="title class_">Person</span>[]; </span><br><span class="line"><span class="comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot;</span></span><br><span class="line"> </span><br><span class="line">type <span class="variable constant_">K3</span> = keyof &#123; [<span class="attr">x</span>: string]: <span class="title class_">Person</span> &#125;;  <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//keyof只会返回共有属性的联合类型。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eg2</span> &#123;</span><br><span class="line">  private <span class="attr">name</span>: string;</span><br><span class="line">  public readonly <span class="attr">age</span>: number;</span><br><span class="line">  protected <span class="attr">home</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// T2实则被约束为 age</span></span><br><span class="line"><span class="comment">// 而name和home不是公有属性，所以不能被keyof获取到</span></span><br><span class="line">type <span class="variable constant_">T2</span> = keyof <span class="title class_">Eg2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-索引访问"><a href="#6-索引访问" class="headerlink" title="6.索引访问"></a>6.索引访问</h3><p>获取到的是对象类型中属性类型组成的联合类型。</p>
<p>如果<code>[]</code>中的key有不存在T中的，则报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Eg1</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string,</span><br><span class="line">  readonly <span class="attr">age</span>: number,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// string</span></span><br><span class="line">type <span class="variable constant_">V1</span> = <span class="title class_">Eg1</span>[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="comment">// string | number</span></span><br><span class="line">type <span class="variable constant_">V2</span> = <span class="title class_">Eg1</span>[<span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"></span><br><span class="line">type <span class="variable constant_">V2</span> = <span class="title class_">Eg1</span>[<span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age2222&#x27;</span>]   <span class="comment">//类型“Eg1”上不存在属性“age2222”</span></span><br><span class="line"><span class="comment">// string | number</span></span><br><span class="line">type <span class="variable constant_">V3</span> = <span class="title class_">Eg1</span>[keyof <span class="title class_">Eg1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-in-amp-x20"><a href="#7-in-amp-x20" class="headerlink" title="7. in&amp;#x20;"></a>7. in&amp;#x20;</h3><p><code>in</code> 用来<strong>遍历联合类型</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Keys</span> = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line">type <span class="title class_">Obj</span> =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> <span class="title class_">Keys</span>]: any   <span class="comment">// [] 是变量属性    //p相当于是临时变量</span></span><br><span class="line">&#125; <span class="comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Obj</span> =  &#123;</span><br><span class="line">  <span class="attr">name</span>:string,</span><br><span class="line">  <span class="attr">age</span>:number</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">type C= &#123;</span><br><span class="line">  [p <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]:any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果in遍历的不是联合类型，则类型别名等价于 <code>&#123;&#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Keys</span> = <span class="string">&quot;a&quot;</span> &amp; <span class="string">&quot;b&quot;</span> &amp; <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line">type <span class="title class_">Obj</span> =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> <span class="title class_">Keys</span>]:any</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-Partial-amp-x20"><a href="#8-Partial-amp-x20" class="headerlink" title="8.Partial&amp;#x20;"></a>8.Partial&amp;#x20;</h3><p><strong>传入一个对象类型</strong>，将对象类型中的所有属性变成可选的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心实现就是通过映射类型遍历T上所有的属性，  后将每个属性设置为可选属性</span></span><br><span class="line">type <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[P in keyof T] 通过映射类型，遍历T上的所有属性,  [] 变量属性 </span></span><br><span class="line"><span class="comment">?: 设置为属性为可选的</span></span><br><span class="line"><span class="comment">T[P]设置类型为原来的类型</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h3 id="9-Readonly"><a href="#9-Readonly" class="headerlink" title="9.Readonly"></a>9.Readonly</h3><p><strong>入一个对象类型</strong>，将对象类型中的所有属性变成只读的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要实现是通过映射遍历所有key，然后给每个key增加一个readonly修饰符</span></span><br><span class="line">type <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-Pick"><a href="#10-Pick" class="headerlink" title="10.Pick"></a>10.Pick</h3><p>传入（一个对象类型，<strong>一个联合类型（必须是keyof  T的子类型）</strong>）， 从对象类型中挑出联合类型中的属性组成新的对象类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Pick</span>&lt;T,K <span class="keyword">extends</span> keyof T&gt; =&#123; [P <span class="keyword">in</span> K]: T[P] &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-Omit"><a href="#11-Omit" class="headerlink" title="11.Omit"></a>11.Omit</h3><p>omit忽略; 删除;&amp;#x20;</p>
<p>传入一个是对象类型，一个联合类型 <strong>（可以是任意联合类型）</strong>，从对象类型中排除传入的联合类型值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type someone = <span class="title class_">Omit</span>&lt;<span class="title class_">Person</span>,<span class="string">&#x27;name&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">type <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof any&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">type <span class="title class_">Omit2</span>&lt;T, K <span class="keyword">extends</span> keyof any&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> <span class="title class_">Exclude</span>&lt;keyof T, K&gt;]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="12-Exclude"><a href="#12-Exclude" class="headerlink" title="12.Exclude"></a>12.Exclude</h3><p>传入两个联合类型，从<strong>联合类型中排除属性</strong>，与extract相反，返回剩下联合类型属性组成的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历T中的所有子类型，如果该子类型约束于U（存在于U、兼容于U），则返回never类型</span></span><br><span class="line"><span class="comment">//否则返回该子类型</span></span><br><span class="line">type <span class="title class_">Exclude</span> &lt;T,U&gt;= T <span class="keyword">extends</span> U ? <span class="attr">never</span>: T   <span class="comment">//如果T中存在U就返回</span></span><br><span class="line"><span class="comment">//T类型是泛型，且泛型传入的是联合类型时，则会分解（依次遍历所有的子类型进行条件判断）联合类型进行判断。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-Extract"><a href="#13-Extract" class="headerlink" title="13.Extract"></a>13.Extract</h3><p>提取联合类型T和联合类型U的所有交集。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Extract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never;</span><br></pre></td></tr></table></figure>

<h3 id="14-Record"><a href="#14-Record" class="headerlink" title="14.Record"></a>14.Record</h3><p>接收两个参数，前一个表示对象的键类型，后一个表示值类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//keyof any 等价于 string | number | symbol</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Record&lt;string, never&gt;</code> 空对象</p>
<p><code>Record&lt;string, unknown&gt;</code> 任意对象</p>
<p><code>&#123;&#125;</code> 任何不为空的对象</p>
<h3 id="15-returnType"><a href="#15-returnType" class="headerlink" title="15.returnType"></a>15.returnType</h3><p>返回函数的返回类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type <span class="variable constant_">T10</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> string&gt;;  <span class="comment">// string</span></span><br><span class="line">type <span class="variable constant_">T11</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">(<span class="params">s: string</span>) =&gt;</span> <span class="keyword">void</span>&gt;;  <span class="comment">// void</span></span><br><span class="line">type <span class="variable constant_">T12</span> = <span class="title class_">ReturnType</span>&lt;(&lt;T&gt;<span class="function">() =&gt;</span> T)&gt;;  <span class="comment">// &#123;&#125;</span></span><br><span class="line">type <span class="variable constant_">T13</span> = <span class="title class_">ReturnType</span>&lt;(&lt;T <span class="keyword">extends</span> U, U <span class="keyword">extends</span> number[]&gt;<span class="function">() =&gt;</span> T)&gt;;  <span class="comment">// number[]</span></span><br><span class="line">type <span class="variable constant_">T14</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> f1&gt;;  <span class="comment">// &#123; a: number, b: string &#125;</span></span><br><span class="line">type <span class="variable constant_">T15</span> = <span class="title class_">ReturnType</span>&lt;any&gt;;  <span class="comment">// any</span></span><br><span class="line">type <span class="variable constant_">T16</span> = <span class="title class_">ReturnType</span>&lt;never&gt;;  <span class="comment">// any</span></span><br><span class="line">type <span class="variable constant_">T17</span> = <span class="title class_">ReturnType</span>&lt;string&gt;;  <span class="comment">// Error</span></span><br><span class="line">type <span class="variable constant_">T18</span> = <span class="title class_">ReturnType</span>&lt;<span class="title class_">Function</span>&gt;;  <span class="comment">// Error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>InstanceType&lt;T&gt;&amp;#x20;</p>
<p>获取构造函数实例的类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type <span class="variable constant_">T20</span> = <span class="title class_">InstanceType</span>&lt;<span class="keyword">typeof</span> C&gt;;  <span class="comment">// C</span></span><br><span class="line">type <span class="variable constant_">T21</span> = <span class="title class_">InstanceType</span>&lt;any&gt;;  <span class="comment">// any</span></span><br><span class="line">type <span class="variable constant_">T22</span> = <span class="title class_">InstanceType</span>&lt;never&gt;;  <span class="comment">// any</span></span><br><span class="line">type <span class="variable constant_">T23</span> = <span class="title class_">InstanceType</span>&lt;string&gt;;  <span class="comment">// Error</span></span><br><span class="line">type <span class="variable constant_">T24</span> = <span class="title class_">InstanceType</span>&lt;<span class="title class_">Function</span>&gt;;  <span class="comment">// Error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="16-Parameters"><a href="#16-Parameters" class="headerlink" title="16.Parameters"></a>16.Parameters</h3><p>Parameters 获取函数的参数类型，将每个参数类型放在一个元组中。如果没有参数就是一个空数组[ ]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Parameters</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Function</span>&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer P) =&gt; any ? P : never;</span><br></pre></td></tr></table></figure>

<p>判断<code>T</code>是否是函数类型，如果是则使用<code>inter P</code>让ts自己推导出函数的参数类型，并将推导的结果存到类型<code>P</code>上，否则就返回<code>never</code>；</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6994102811218673700" title="Ts高手篇：22个示例深入讲解Ts最晦涩难懂的高级类型工具 - 掘金 (juejin.cn)">Ts高手篇：22个示例深入讲解Ts最晦涩难懂的高级类型工具 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.wolai.com/dz73SCqTwqXc5TyMDuJ74c" title="遇到过的问题">遇到过的问题</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xiaozhwien.cluod">肖智文</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xiaozhwien.cluod/ts/typeScript/">https://xiaozhwien.cluod/ts/typeScript/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xiaozhwien.cluod" target="_blank">Wen</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ts/">ts</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://xiaozhiwen-hexo.oss-cn-hangzhou.aliyuncs.com/hexo-img/f178a405aa4907345cd364a966f5ba7.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xiaozhiwen-hexo.oss-cn-hangzhou.aliyuncs.com/hexo-img/f178a405aa4907345cd364a966f5ba7.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://xiaozhiwen-hexo.oss-cn-hangzhou.aliyuncs.com/hexo-img/f178a405aa4907345cd364a966f5ba7.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xiaozhiwen-hexo.oss-cn-hangzhou.aliyuncs.com/hexo-img/7ffe3896b9e0a22f4e53902507cd6c3.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/webpack/webpack/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">webpack</div></div></a></div><div class="next-post pull-right"><a href="/webpack/webpack%E7%9A%84loader,plugin%E5%8E%9F%E7%90%86/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">webpack的loader,plugin原理</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#typeScript"><span class="toc-number">1.</span> <span class="toc-text">typeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.</span> <span class="toc-text">安装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-amp-x20"><span class="toc-number">2.</span> <span class="toc-text">一、数据类型&amp;#x20;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%A7%88"><span class="toc-number">2.1.</span> <span class="toc-text">1.概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">2.详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tuple-%E5%85%83%E7%BB%84"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">tuple 元组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enum-%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.2.0.4.</span> <span class="toc-text">enum 枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-amp-x20"><span class="toc-number">2.2.0.5.</span> <span class="toc-text">void&amp;#x20;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#never-%E4%BA%86%E8%A7%A3"><span class="toc-number">2.2.0.6.</span> <span class="toc-text">never (了解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#any-amp-x20"><span class="toc-number">2.2.0.7.</span> <span class="toc-text">any     &amp;#x20;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unknown-amp-x20"><span class="toc-number">2.2.0.8.</span> <span class="toc-text">unknown&amp;#x20;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object%E3%80%81Object%E3%80%81"><span class="toc-number">2.2.0.9.</span> <span class="toc-text">object、Object、{}</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E6%96%AD%E8%A8%80-%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB"><span class="toc-number">3.</span> <span class="toc-text">二,断言 类型守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">3.1.</span> <span class="toc-text">1.类型推断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80"><span class="toc-number">3.2.</span> <span class="toc-text">2.非空断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">3.3.</span> <span class="toc-text">3.类型断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB"><span class="toc-number">3.4.</span> <span class="toc-text">4.类型守卫</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">4.</span> <span class="toc-text">三、类型的一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B-%EF%BC%88%E6%88%96%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">1.  |  联合类型   （或）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-amp-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B-%EF%BC%88%E4%B8%94%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2. &amp; 交叉类型    （且）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D-type"><span class="toc-number">4.3.</span> <span class="toc-text">3.类型别名 type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%AE%BD"><span class="toc-number">4.4.</span> <span class="toc-text">4.类型扩宽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E6%89%A9%E5%AE%BD"><span class="toc-number">4.4.1.</span> <span class="toc-text">限制扩宽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A0%87%E7%AD%BE%E8%81%94%E5%90%88%EF%BC%88%E5%8F%AF%E8%BE%A8%E8%AF%86%E8%81%94%E5%90%88%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">5.标签联合（可辨识联合）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">四、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">1.函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.</span> <span class="toc-text">2.函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-this%E6%8C%87%E5%90%91%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">3. this指向（了解）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">五、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">1.接口的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-interface-%E5%92%8Ctype%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.interface 和type的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">6.1.2.</span> <span class="toc-text">2.接口和抽象类的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">6.1.3.</span> <span class="toc-text">3. 索引签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%B8%AD%E5%BC%8F%E8%BE%A8%E5%BD%A2%E6%B3%95"><span class="toc-number">6.1.4.</span> <span class="toc-text">6.鸭式辨形法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">六、类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.1.</span> <span class="toc-text">1.修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#public-%E9%BB%98%E8%AE%A4"><span class="toc-number">7.1.1.</span> <span class="toc-text">public 默认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#private-amp-x20"><span class="toc-number">7.1.2.</span> <span class="toc-text">private&amp;#x20;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protected-amp-x20"><span class="toc-number">7.1.3.</span> <span class="toc-text">protected&amp;#x20;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-amp-x20"><span class="toc-number">7.1.4.</span> <span class="toc-text">static&amp;#x20;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readonly"><span class="toc-number">7.1.5.</span> <span class="toc-text">readonly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstract"><span class="toc-number">7.1.6.</span> <span class="toc-text">abstract</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%B3%9B%E5%9E%8B-Generics"><span class="toc-number">8.</span> <span class="toc-text">七、泛型 Generics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text">1.泛型简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E5%AE%9A%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.1.1.</span> <span class="toc-text">函数指定泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%8C%87%E5%AE%9A%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.1.2.</span> <span class="toc-text">类指定泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%AE%9A%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.1.3.</span> <span class="toc-text">接口指定泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%90%8C%E6%97%B6%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.2.</span> <span class="toc-text">2.同时指定多个泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F-extends"><span class="toc-number">8.3.</span> <span class="toc-text">3.泛型约束 extends</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B3%9B%E5%9E%8B%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B-utility-types"><span class="toc-number">8.4.</span> <span class="toc-text">4.泛型工具类型 utility types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">8.4.1.</span> <span class="toc-text">1. 类型兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98"><span class="toc-number">8.4.1.1.</span> <span class="toc-text">协变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%8F%98"><span class="toc-number">8.4.1.2.</span> <span class="toc-text">逆变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%8D%8F%E5%8F%98"><span class="toc-number">8.4.1.3.</span> <span class="toc-text">双向协变</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-extends-amp-x20"><span class="toc-number">8.4.2.</span> <span class="toc-text">2.extends&amp;#x20;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-infer"><span class="toc-number">8.4.3.</span> <span class="toc-text">3. infer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-typeof-amp-x20"><span class="toc-number">8.4.4.</span> <span class="toc-text">4. typeof&amp;#x20;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-keyof-%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.4.5.</span> <span class="toc-text">5. keyof  索引查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE"><span class="toc-number">8.4.6.</span> <span class="toc-text">6.索引访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-in-amp-x20"><span class="toc-number">8.4.7.</span> <span class="toc-text">7. in&amp;#x20;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Partial-amp-x20"><span class="toc-number">8.4.8.</span> <span class="toc-text">8.Partial&amp;#x20;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Readonly"><span class="toc-number">8.4.9.</span> <span class="toc-text">9.Readonly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Pick"><span class="toc-number">8.4.10.</span> <span class="toc-text">10.Pick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Omit"><span class="toc-number">8.4.11.</span> <span class="toc-text">11.Omit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Exclude"><span class="toc-number">8.4.12.</span> <span class="toc-text">12.Exclude</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Extract"><span class="toc-number">8.4.13.</span> <span class="toc-text">13.Extract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Record"><span class="toc-number">8.4.14.</span> <span class="toc-text">14.Record</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-returnType"><span class="toc-number">8.4.15.</span> <span class="toc-text">15.returnType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Parameters"><span class="toc-number">8.4.16.</span> <span class="toc-text">16.Parameters</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 By 肖智文</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="icp链接"><img class="icp-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gw.alicdn.com/tfs/TB1jwakrbH1gK0jSZFwXXc7aXXa-20-20.png"><span>备案号：赣ICP备2022003304号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-phi-blue.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-phi-blue.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div></div></body></html>